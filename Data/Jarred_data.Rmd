---
title: "Watauga"
author: "Jarred_Randall"
date: "2024-02-12"
output: html_document
---
```{r clear_environment, cache=TRUE, include=F}

rm(list=ls())

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r Library}
install.packages("FedData")
install.packages("animation")
library(raster) 
library(rgdal)
library(animation)
library(rasterVis)
library(FedData)
library(tidyverse)
library(tidycensus)
library(sf)
library(dplyr)
library(raster) 
library(rgdal)
library(animation)
library(rasterVis)
library(RColorBrewer) 
library(ggplot2)      
library(colorspace)
library(dplyr)
library(tidyr)
library(readr)
library(sf)
library(terra)
library(kableExtra)
library(terra)



color_palette <- c("#e2a334", "#f9bf3e", "#fcd977", "#9ad7d2", "#74c1b9")
```
# Write up

## Problem Statement / Use Case

Watauga County, North Carolina, is currently experiencing a housing shortage that is expected to intensify in the near future. The shortage is exacerbated by vacation rentals and student housing, which has significantly reduced the available residential housing options. The Watauga Housing Solutions Committee is partnering with other community and local government organizations looking to develop affordable and workforce housing in order to mitigate the severe decreases in housing affordability. They are working with a developer to prioritize the most feasible sites to pursue for purchase and development. Because of the extreme physical conditions of the landscape (slope, soils, etc.) there is currently no streamlined system in place to help identify suitable parcels for development. In response to this issue, we have been contracted to develop an application-based data framework that is designed to identify land parcels based on their likelihood to be developed for affordable and workforce housing.  This data framework will be designed to function as an interactive application interface that will allow users to input criteria related to land supply and combine it with development likelihood estimates to rank each parcel in the county in terms of suitability.

## Project Client:

The main project client is the Watauga Housing Council and its Housing Solutions Committee. This organization is tasked with responding to the economic, environmental, and social aspects of the county to provide adequate housing options for all residents. our main points of contacts within the housing council are Dr. Kellie Reed Ashcraft, Facilitator/Organizer, Watauga Housing Council, Dr. Chris Quattro, Assistant Professor, Appalachian State University/Member, Watauga Housing Council , Laura Beach, Member, Watauga Housing Council. 

## Dependent Variable: Septic System Permits 
The key indicator for development (dependent variable) that will be used is the administrative record associated with septic system permits. This permit is exclusively granted when a property satisfies the requirements for both land supply and developer demand at that specific site. Due to the rural nature of the project area, there is relatively low wastewater sewer coverage. subsequently, a septic system is critical for new development, and a site cannot be developed without one. Our approach will involve identifying the site suitability characteristics (e.g., slope, soils) most closely related to the probability of a parcel receiving a septic permit. Using this information, we will forecast the likelihood that a given parcel will receive a new septic permit. 


# Data Wrangling Percent Rent Burdened by Surrounding Counties 
```{r}

county17 <- 
  get_acs(geography = "county", 
          variables = c("B25070_007E",
                        "B25070_008E",
                        "B25070_009E",
                        "B25070_010E",
                        "B25070_011E",
                        "B25003_003E"), 
          year=2017, state="NC", 
          geometry=TRUE, output="wide") %>%
  st_transform('EPSG:4326') %>%
  rename(RentBurden_30_35 = B25070_007E,
         RentBurden_35_39 = B25070_008E,
         RentBurden_40_49 = B25070_009E,
         RentBurden_50_99 = B25070_010E,
         RentBurden_60_more = B25070_011E,
         total_renter_occupied = B25003_003E) %>%
  dplyr::select(-starts_with("B")) %>%
  mutate(rent_burdened_households = RentBurden_30_35 + RentBurden_35_39 + RentBurden_40_49 + RentBurden_50_99 + RentBurden_60_more,
         Percent_rent_burdened = round((rent_burdened_households / total_renter_occupied) * 100, 0),
         NAME = str_replace(NAME, ", North Carolina", "")) %>%
  dplyr::filter(NAME %in% c("Avery County", "Wilkes County", "Ashe County", "Watauga County","Caldwell County")) %>%
  dplyr::select(GEOID, NAME, rent_burdened_households, total_renter_occupied, Percent_rent_burdened)



county22 <- 
  get_acs(geography = "county", 
          variables = c("B25070_007E",
                        "B25070_008E",
                        "B25070_009E",
                        "B25070_010E",
                        "B25070_011E",
                        "B25003_003E"), 
          year=2022, state="NC", 
          geometry=TRUE, output="wide") %>%
  st_transform('EPSG:4326') %>%
  rename(RentBurden_30_35 = B25070_007E,
         RentBurden_35_39 = B25070_008E,
         RentBurden_40_49 = B25070_009E,
         RentBurden_50_99 = B25070_010E,
         RentBurden_60_more = B25070_011E,
         total_renter_occupied = B25003_003E) %>%
  dplyr::select(-starts_with("B")) %>%
  mutate(rent_burdened_households = RentBurden_30_35 + RentBurden_35_39 + RentBurden_40_49 + RentBurden_50_99 + RentBurden_60_more,
         Percent_rent_burdened = round((rent_burdened_households / total_renter_occupied) * 100, 0),
         NAME = str_replace(NAME, ", North Carolina", "")) %>%
  dplyr::filter(NAME %in% c("Avery County", "Wilkes County", "Ashe County", "Watauga County", "Caldwell County")) %>%
  dplyr::select(GEOID, NAME, rent_burdened_households, total_renter_occupied, Percent_rent_burdened)

county17 <- county17 %>% mutate(year = 2017)
county22 <- county22 %>% mutate(year = 2022)

combined_years <- bind_rows(county17, county22)



county22 <- 
  get_acs(geography = "county", 
          variables = c("B25070_007E",
                        "B25070_008E",
                        "B25070_009E",
                        "B25070_010E",
                        "B25070_011E",
                        "B25003_003E"), 
          year=2022, state="NC", 
          geometry=TRUE, output="wide") %>%
  st_transform('EPSG:4326') %>%
  rename(RentBurden_30_35 = B25070_007E,
         RentBurden_35_39 = B25070_008E,
         RentBurden_40_49 = B25070_009E,
         RentBurden_50_99 = B25070_010E,
         RentBurden_60_more = B25070_011E,
         total_renter_occupied = B25003_003E) %>%
  dplyr::select(-starts_with("B"))

```

# Maps
```{r}

ggplot(data = county17) +
  geom_sf(aes(fill = Percent_rent_burdened)) + # Removed color = color_palette here
  scale_fill_gradientn(colors = color_palette) + # Use this to apply your color palette
  geom_sf_text(aes(label = NAME), 
               size = 4, # Adjusted size
               colour = "black", 
               check_overlap = TRUE,
               fontface = "bold") + # Make text bold
  geom_sf_text(aes(label = paste0(Percent_rent_burdened, "%")), 
               size = 3.5, # Adjusted size
               colour = "black", 
               check_overlap = TRUE, 
               nudge_y = -0.05,
               fontface = "bold") + # Make text bold
  labs(title = "Rent Burdened Households by County",
       subtitle = "Year: 2017") +
  theme_void() +
  theme(legend.position = "right")
```


```{r}

ggplot(data = county22) +
  geom_sf(aes(fill = Percent_rent_burdened)) + # Removed color = color_palette here
  scale_fill_gradientn(colors = color_palette) + # Use this to apply your color palette
  geom_sf_text(aes(label = NAME), 
               size = 4, # Adjusted size
               colour = "black", 
               check_overlap = TRUE,
               fontface = "bold") + # Make text bold
  geom_sf_text(aes(label = paste0(Percent_rent_burdened, "%")), 
               size = 3.5, # Adjusted size
               colour = "black", 
               check_overlap = TRUE, 
               nudge_y = -0.05,
               fontface = "bold") + # Make text bold
  labs(title = "Rent Burdened Households by County",
       subtitle = "Year: 2022") +
  theme_void() +
  theme(legend.position = "right")
```

```{r read_data}

boundary <- st_read("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/GeoJSON/Boundary.geojson")

fire_districts <- st_read("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/GeoJSON/FireDistricts_FeaturesToJSON.geojson")

managed_areas <- st_read("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/GeoJSON/managed_areasToJSON.geojson")

natural_areas <- st_read("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/GeoJSON/Natural_area_JSON.geojson")

zoned_areas <- st_read("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/GeoJSON/zonedareas_FeaturesToJSON.geojson")

municipal_bound <- st_read("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/GeoJSON/NCDOT_Municipal_Boundaries.geojson")

county_bound <- st_read("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/GeoJSON/NCDOT_County_Boundaries.geojson")

parcels <- st_read("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/Data/parcel/parcel.geojson")

# Landcover Vector

legend<-pal_nlcd()

lc_2021 <- raster("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/Data/Landuse_Raster/lulc_2021")
lc_2019 <- raster("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/Data/Landuse_Raster/lulc_2019")
lc_2016 <- raster("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/Data/Landuse_Raster/lulc_2016")
lc_2013 <- raster("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/Data/Landuse_Raster/lulc_2013")
lc_2011 <- raster("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/Data/Landuse_Raster/lulc_2011")


```

```{r}

ggplot() +
  geom_sf(data = boundary, fill = NA, color = "black") + 
  geom_sf(data = managed_areas, aes(fill = OWNER_TYPE)) + 
  scale_fill_manual(values = color_palette) + 
  labs(title = "Watauga Managed Areas by Owner Type",
       subtitle = "Year: 2022") +
  theme_void() +
  theme(legend.position = "right")
```
```{r}

ggplot() +
  geom_sf(data = boundary, fill = NA, color = "black") + 
  geom_sf(data = natural_areas, aes(fill = C_RATING)) + 
  scale_fill_manual(values = color_palette) + 
  labs(title = "Watauga Natural",
       subtitle = "Year: 2022") +
  theme_void() +
  theme(legend.position = "right")
```

####### Updated Landcover section

### Watauga 2021 Land cover 

The Watauga County 2021 land cover underscores the county's rich natural resources and moderate urban development. The total land cover area is predominantly forested land (74.56%), with 54.16% of the county’s land cover area being deciduous forest and 19.2% mixed forest, and 1.2% evergreen forest. Developed areas, which is limited to about 13.89% of the total land cover area is made up of 11.23% of developed open space, 1.48% developed low intensity, 0.9% developed medium density, 0.28% developed high intensity. The majority of development is classified as open space, which could encompass parks, golf courses, or agricultural land that adds to the rural character of the county. The incrementally smaller percentages for low, medium, and high-intensity developments indicate concentrated urbanization around cities and transportation corridors, reflecting strategic land use planning that preserves the natural landscape while accommodating residential and commercial needs.

```{r lc_2021, echo=FALSE, message=FALSE, warning=FALSE}
s <- stack(lc_2011, lc_2013, lc_2016,lc_2019, lc_2021 )

myKey <- list(
  rectangles = list(col = df$Color),
  text = list(lab = df$Class),
  space = 'right',
  columns = 1,
  size = 2,
  cex = .6
)

vals <-unique(s[[5]])  # Get unique values from lc_2021
df <- legend[legend$ID %in% vals,]  # Filter legend information based on lc_2021 values
rat5 <- ratify(lc_2021)

levelplot(rat5, att='ID', 
          col.regions=df$Color,
          maxpixels=ncell(rat5), # Try setting maxpixels to the number of cells in the raster
          par.settings = list(
            axis.line = list(col = "transparent"), 
            strip.background = list(col = 'transparent'), 
            strip.border = list(col = 'transparent')
          ), 
          scales = list(col = "transparent"),
          colorkey = FALSE,
          key = myKey,
          main = "Watauga 2021 Land Cover") # Title added here

```

#### Land Cover 10 year changes {.tabset}

From 2011 and 2021 Watauga County witnessed a notable shift in land cover, particularly in terms of development and the reduction of natural landscapes like grasslands and shrublands. The data indicates a 13.89% increase in developed areas, with significant growth in low, medium, and high-intensity developments. Most notably, medium intensity development saw a significant increase of 17.22% in 2021. Concurrently, the county experienced a dramatic 56.5% decrease in Grassland/Herbaceous areas and a 50% reduction in Shrub/Scrub land. These changes could be attributed to several factors, including the conversion of open fields and grasslands into developed land or possibly into agricultural use. The majority of the land cover remains natural or semi-natural, with developed open spaces also experiencing a small rise. The data suggests a careful balance between development and the maintenance of natural land covers over the past decade.

##### 2011-2021 {.unnumbered}

```{r lc_time_series, echo=FALSE, message=FALSE, warning=FALSE}

years.list <- list("2011", "2013", "2016", "2019", "2021")


suppressMessages({saveGIF({
  for(i in 1:nlayers(s)){
    rat <- ratify(s[[i]])
    plot <- levelplot(rat, att='ID',
              maxpixels=ncell(rat),
              col.regions=df$Color,
              par.settings = list(axis.line = list(col = "transparent"), 
                                  strip.background = list(col = 'transparent'), 
                                  strip.border = list(col = 'transparent')), 
              scales = list(col = "transparent"),
              main=paste0("Watauga County land cover ", years.list[[i]]),
              colorkey=FALSE)
    print(plot)
  }
}, interval=1, movie.name="lc_time_series.gif", ani.width=1200, ani.height=900)})
```

##### 2011 {.unnumbered}

```{r lc_2011, echo=FALSE, message=FALSE, warning=FALSE}



rat <- ratify(lc_2011)

myKey <- list(
  rectangles = list(col = df$Color),
  text = list(lab = df$Class),
  space = 'right',
  columns = 1,
  size = 2,
  cex = .6
)
levelplot(rat, att='ID', 
          col.regions=df$Color,
          maxpixels=ncell(rat), # Try setting maxpixels to the number of cells in the raster
          par.settings = list(
            axis.line = list(col = "transparent"), 
            strip.background = list(col = 'transparent'), 
            strip.border = list(col = 'transparent')
          ), 
          scales = list(col = "transparent"),
          colorkey = FALSE,
          key = myKey,
          main = "Watauga 2011 Land Cover") # Title added here
```


##### 2013 {.unnumbered}
```{r lc_2013, echo=FALSE, message=FALSE, warning=FALSE}
rat2 <- ratify(lc_2013)

levelplot(rat2, att='ID', 
          col.regions=df$Color,
          maxpixels=ncell(rat2), # Try setting maxpixels to the number of cells in the raster
          par.settings = list(
            axis.line = list(col = "transparent"), 
            strip.background = list(col = 'transparent'), 
            strip.border = list(col = 'transparent')
          ), 
          scales = list(col = "transparent"),
          colorkey = FALSE,
          key = myKey,
          main = "Watauga 2013 Land Cover") # Title added here
```

##### 2016 {.unnumbered}
```{r lc_2016, echo=FALSE, message=FALSE, warning=FALSE}
rat3 <- ratify(lc_2016)

levelplot(rat3, att='ID', 
          col.regions=df$Color,
          maxpixels=ncell(rat3), # Try setting maxpixels to the number of cells in the raster
          par.settings = list(
            axis.line = list(col = "transparent"), 
            strip.background = list(col = 'transparent'), 
            strip.border = list(col = 'transparent')
          ), 
          scales = list(col = "transparent"),
          colorkey = FALSE,
          key = myKey,
          main = "Watauga 2016 Land Cover") # Title added here
```

##### 2019 {.unnumbered}
```{r lc_2019, echo=FALSE, message=FALSE, warning=FALSE}
rat4 <- ratify(lc_2019)

levelplot(rat4, att='ID', 
          col.regions=df$Color,
          maxpixels=ncell(rat4), # Try setting maxpixels to the number of cells in the raster
          par.settings = list(
            axis.line = list(col = "transparent"), 
            strip.background = list(col = 'transparent'), 
            strip.border = list(col = 'transparent')
          ), 
          scales = list(col = "transparent"),
          colorkey = FALSE,
          key = myKey,
          main = "Watauga 2019 Land Cover") # Title added here
```

##### 2021 {.unnumbered}

```{r lc_2021_2, echo=FALSE, message=FALSE, warning=FALSE}
vals <-unique(s[[5]])  # Get unique values from lc_2021
df <- legend[legend$ID %in% vals,]  # Filter legend information based on lc_2021 values
rat5 <- ratify(lc_2021)

levelplot(rat5, att='ID', 
          col.regions=df$Color,
          maxpixels=ncell(rat5), # Try setting maxpixels to the number of cells in the raster
          par.settings = list(
            axis.line = list(col = "transparent"), 
            strip.background = list(col = 'transparent'), 
            strip.border = list(col = 'transparent')
          ), 
          scales = list(col = "transparent"),
          colorkey = FALSE,
          key = myKey,
          main = "Watauga 2021 Land Cover") # Title added here

```


###### udpate ends here




```{r}

years.list <- list("2011", "2013", "2016", "2019", "2021")


saveGIF({
  for(i in 1:nlayers(s)){
    rat <- ratify(s[[i]])
    plot <- levelplot(rat, att='ID',
              maxpixels=ncell(rat),
              col.regions=df$Color,
              par.settings = list(axis.line = list(col = "transparent"), 
                                  strip.background = list(col = 'transparent'), 
                                  strip.border = list(col = 'transparent')), 
              scales = list(col = "transparent"),
              main=paste0("Watauga County land cover ", years.list[[i]]),
              colorkey=FALSE)
    print(plot)
  }
}, interval=1, movie.name="lc_time_series.gif", ani.width=1200, ani.height=900)




```



```{r}

years<-c(2011, 2013, 2016, 2019, 2021)

d<-df
for (i in 1:length(years)) {
  d<-merge(d, freq(s[[i]]), by.x="ID" ,by.y="value", all.y=F, all.x=T)
  names(d)[ncol(d)]<-paste0("pix_", years[[i]])
  }


d$square.mile.change<-(d$pix_2021 - d$pix_2011) * 30 * 30 * 0.00000038610
d$percentchange<-(d$pix_2021 - d$pix_2011)/d$pix_2011
d$prop2021<-d$pix_2021/sum(d$pix_2021)

d$percentchange.2011.2021<-paste(round(100*d$percentchange, 2), "%", sep="")
d$percent.area.2021<-paste(round(100*d$prop2021, 2), "%", sep="")




kable(d[,c(2,10,13,14)])  %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)



```

```{r}

library(rgdal)
library(raster)
library(rayshader)
library(sp)

landcover <- raster("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/Data/Landuse_Raster/lulc_2021")
elevation <- raster("C:/Users/fatbo/OneDrive/Documents/GitHub/Musa_801_Watauga/Data/Landuse_Raster/dem")

# Reclassify landcover data if necessary
reclass_matrix <- matrix(c(0,1,1, 2,3,2, 4,5,3), ncol=3, byrow=TRUE)
landcover_reclassified <- reclassify(landcover, reclass_matrix)

# Convert the elevation raster to a matrix
elevation_matrix <- matrix(raster::extract(elevation, raster::extent(elevation), buffer=1000),
                           nrow = ncol(elevation), ncol = nrow(elevation))

# Use rayshader to plot
elevation_matrix %>%
  sphere_shade(texture = "desert") %>%
  add_water(detect_water(elevation_matrix), color = "desert") %>%
  plot_3d(elevation_matrix, zscale = 10, fov = 0, theta = 0, phi = 90, windowsize = c(1000, 800))

# To save the 3D plot
rgl::rgl.snapshot("watauga_3d_landcover.png")

```

```{r}
parcels = spTransform(parcels,crs(lc_2016))



# Only if you are using the raster package and lc_2016 is a RasterLayer
library(raster)

# Reproject the raster to match the CRS of the parcels vector data
lc_2016_reproj <- projectRaster(lc_2016, crs=crs(parcels))
lc_2021_reproj <- projectRaster(lc_2021, crs=crs(parcels))

# Extract raster values into a list (each list element corresponds to a parcel)
land_cover_values <- extract(lc_2016_reproj, parcels)

# If you want to directly append the most frequent land cover type to the parcels, use:
parcel_data$land_cover_type <- lapply(land_cover_values, function(x) {
  names(sort(table(x), decreasing = TRUE))[1]
})

unique_land_cover_values <- unique(lc_2021_reproj[])


# Define land cover classes based on the provided IDs
classes <- c(11, 12, 21, 22, 23, 24, 31, 41, 42, 43, 
             51, 52, 71, 72, 73, 74, 81, 82, 90, 95)



# Load required library
install.packages("exactextractr")
library(exactextractr)



# Load vector parcel file


# Perform exact extraction for each parcel
extracted_values <- Map(exactextractr::exact_extract, rep(list(lc_2016_reproj), nrow(parcels)), sf::st_geometry(parcels))

# Calculate total area of each parcel
parcel_areas <- sf::st_area(parcels)

# Calculate percentages of land use types within each parcel
percentage_landuse <- lapply(extracted_values, function(x) {
  if (length(x) == 0) {
    percentages <- rep(NA, ncol(landuse))
  } else {
    percentages <- x / sum(x) * 100  # Calculate percentage
  }
  return(percentages)
})

# Combine percentages with parcel IDs
result <- cbind(parcels$PARCELID, do.call(rbind, percentage_landuse))
colnames(result) <- c("Parcel_ID", levels(landuse))

# Print or save the result
print(result)


sum_cover <- function(x){
  list(x %>%
    group_by(value) %>%
    summarize(total_area = sum(coverage_area)) %>%
    mutate(proportion = total_area/sum(total_area)))
  
}

#extract the area of each raster cell covered by the plot and summarize
x <- exact_extract(lc_2016_reproj, parcels, coverage_area = TRUE, summarize_df = TRUE, fun = sum_cover)


#add plot names to the elements of the output list
names(x) <- parcels$PARCELID

#merge the list elements into a df
test <- bind_rows(x, .id = "Plot_buffer")



library(terra)
r <- rast(system.file("ex/elev.tif", package="terra"))
r <- round(r/100)
v <- vect(system.file("ex/lux.shp", package="terra"))


lc_2016_reproj_test <- crop(lc_2016_reproj, parcels[1:2, ], mask=TRUE)

freq(lc_2016_reproj_test)
#  layer value count
#1     1     2    47
#2     1     3   219
#3     1     4   314
#4     1     5   475

a <- cellSize(lc_2016_reproj)
zonal(a, lc_2016_reproj)
zonal(a, lc_2016_reproj)
#  elevation     area
#1         2 555404.2
#2         3 555412.9
#3         4 554315.4
#4         5 553053.0



}

unique_values <- unique(parcels$PARCELID)
number_of_unique_values <- length(unique_values)

count(unique_values)



extracted_values <- extract(landcover_raster, parcels, df = TRUE)

# Combine the extracted data with the parcels data
combined_data <- cbind(parcels, extracted_values)

# Use table or aggregate to count the landcover types for each GlobalID
landcover_counts <- aggregate(combined_data$layer, by = list(combined_data$GlobalID), FUN = function(x) table(factor(x, levels = unique(combined_data$layer))))

# Now landcover_counts should have the counts of landcover types for each GlobalID.



# Extract the raster values using the parcel polygons
extracted_values <- extract(lc_2016_reproj, parcels, df = TRUE)

# Combine the extracted data with the parcels data
combined_data <- cbind(parcels, extracted_values)

# Use table or aggregate to count the landcover types for each GlobalID
landcover_counts <- aggregate(combined_data$layer, by = list(combined_data$GlobalID), FUN = function(x) table(factor(x, levels = unique(combined_data$layer))))

# Now landcover_counts should have the counts of landcover types for each GlobalID.

```

```{r}

library(raster)
library(sf)
library(exactextractr)



# Use exact_extract to get the count of each landcover type within each parcel
coverage_stats <- exactextractr::exact_extract(lc_2016_reproj, parcels, function(values, fraction) {
  if (length(values) == 0) {
    return(data.frame(count = 0, percentage = 0))
  }
  data.frame(table(factor(values, levels = unique(values))), fraction = fraction)
})

# Process the extracted data
# The coverage_stats is a list with one element per feature in `parcels`
# Each element is a data frame with the count of each raster value (landcover type) in the feature

# Initialize an empty data frame to store the counts per GlobalID
landcover_counts <- data.frame()

# Loop through the list to populate the data frame
for (i in seq_along(coverage_stats)) {
  feature_stats <- coverage_stats[[i]]
  global_id <- parcels$GlobalID[i]
  
  for (landcover_type in unique(landcover_raster[])) {
    if (!landcover_type %in% feature_stats$values) {
      feature_stats <- rbind(feature_stats, data.frame(values = landcover_type, count = 0, percentage = 0))
    }
  }
  
  # Add the GlobalID to the stats
  feature_stats$GlobalID <- global_id
  
  # Combine with the main data frame
  landcover_counts <- rbind(landcover_counts, feature_stats)
}

# Now, `landcover_counts` contains the count and percentage of each landcover type within each parcel

ext <- raster::extract(lc_2016_reproj, parcels)

tab <- sapply(ext, function(x) tabulate(x, 10))
tab <- tab / colSums(tab)


f <- freq(lc_2016_reproj, useNA='no')
apc <- prod(res(lc_2016_reproj))
f <- cbind(f, area=f[,2] * apc)
f

#     value count    area
#[1,]     1    78  124800
#[2,]     2  1750 2800000
#[3,]     3   819 1310400
#[4,]     4   304  486400
#[5,]     5   152  243200

a <- rasterToPolygons(aggregate(r, 25))

# extract values (slow)
ext <- extract(r2, a)

# tabulate values for each polygon
tab <- sapply(ext, function(x) tabulate(x, 5))
# adjust for area (planar data only)
tab <- tab * prod(res(r2))

# check the results, by summing over the regions
rowSums(tab)
#[1]  124800 2800000 1310400  486400  243200 





}

# Calculate the coverage fraction and value of each landcover type for each polygon
coverage_fraction <- exact_extract(lc_2016_reproj, parcels, progress = TRUE)

# Process the extracted data to calculate the percentage of each landcover type
percentages <- lapply(coverage_fraction, function(x) {
  total_area <- sum(x$coverage_fraction) # Total covered area within the polygon
  # Calculate the percentage of each landcover type
  landcover_pct <- tapply(x$coverage_fraction, x$value, sum) / total_area * 100
  return(landcover_pct)
})
percentages



percentage_dfs <- lapply(coverage_fraction, function(x) {
  total_area <- sum(x$coverage_fraction)
  landcover_pct <- tapply(x$coverage_fraction, x$value, sum) / total_area * 100
  return(as.data.frame(t(landcover_pct)))
})

# Combine all the data frames into a single data frame
percentage_df <- do.call(rbind, percentage_dfs)

# If you need to add an identifier for each row, use the following line
percentage_df$GlobalID <- parcels$GlobalID

# Convert wide format to long format if necessary
percentage_long_df <- gather(percentage_df, key = "LandcoverType", value = "Percentage", -GlobalID)

# To have each landcover type as a column and parcels as rows
percentage_wide_df <- pivot_wider(percentage_long_df, names_from = LandcoverType, values_from = Percentage)

# Now merge this with your original parcels data if you want to include other parcel attributes
final_df <- left_join(parcels, percentage_wide_df, by = "GlobalID")

# View the table
View(final_df)

write.csv(final_df, "final_df.csv", row.names = FALSE)


terra::extract(lc_2016_reproj, parcels, exact = TRUE, mean = table)
```
```{r}

crs_raster <- crs(lc_2016)
crs_vector <- st_crs(parcels)

parcel_polygons <- st_transform(parcels, crs = crs_raster)

#Extract the unique values (land cover types) from the raster:
landcover_types <- unique(values(lc_2016))

#Create a function to calculate the percentage of each land cover type within each parcel polygon

library(raster)
library(sf)


# Ensure that the raster and vector data have the same CRS
parcel_polygons <- st_transform(parcel_polygons, crs = crs(lc_2016))

landcover_types <- unique(values(lc_2016))

calculate_landcover_percentages <- function(parcel_polygon) {
  parcel_area <- st_area(parcel_polygon)
  raster_extent <- extent(lc_2016)
  
  landcover_counts <- numeric(length(landcover_types))
  names(landcover_counts) <- landcover_types
  
  for (x in seq(raster_extent@xmin, raster_extent@xmax, by = res(lc_2016)[1])) {
    for (y in seq(raster_extent@ymin, raster_extent@ymax, by = res(lc_2016)[2])) {
      point <- st_point(c(x, y))
      if (st_intersects(point, parcel_polygon, sparse = FALSE)) {
        raster_value <- extract(lc_2016, point)
        landcover_counts[as.character(raster_value)] <- landcover_counts[as.character(raster_value)] + 1
      }
    }
  }
  
  landcover_percentages <- landcover_counts / parcel_area * 100
  landcover_percentages[is.na(landcover_percentages)] <- 0
  return(landcover_percentages)
}

landcover_percentages <- lapply(st_geometry(parcel_polygons), calculate_landcover_percentages)
landcover_percentages_df <- data.frame(
  objectid = parcel_polygons$objectid,
  geospatial_info = st_as_text(parcel_polygons$geometry),
  landcover_percentages
)

```

```{r LC_2016_PER}
options(scipen = 999, digits = 2)

library(sf)
library(raster)
library(exactextractr)
library(dplyr)
library(tidyr)

parcels <- parcels
landcover_2016 <- lc_2016

# Transform CRS of parcels to match the landcover raster if they are different
if (st_crs(parcels) != crs(landcover_2016)) {
  parcels <- st_transform(parcels, crs = crs(landcover_2016))
}

# Perform the exact extraction
coverage <- exact_extract(landcover_2016, parcels, include_cols = c("OBJECTID"))
# Function to calculate percentages
calculate_percentages <- function(df) {
  total_area <- sum(df$coverage_fraction)
  percentages <- 100 * df$coverage_fraction / total_area
  return(percentages)
}

# Calculate percentages and bind them to a new data frame
parcel_percentages <- do.call(rbind, lapply(coverage, function(x) {
  percentages <- calculate_percentages(x)
  x$percentage <- percentages
  return(x)
}))

# Spread the data to wide format
parcel_percentages_wide <- parcel_percentages %>%
  group_by(OBJECTID, value) %>%
  summarize(percentage = sum(percentage, na.rm = TRUE)) %>%
  ungroup() %>%
  pivot_wider(names_from = value, values_from = percentage, names_prefix = "Landcover_")

# Merge with original parcels data to include geospatial information
final_dataset <- parcels %>%
  left_join(parcel_percentages_wide, by = "OBJECTID")


# View the final dataset
View(final_dataset)

# Alternatively, write to a CSV file
write.csv(final_dataset, "parcel_landcover_percentages.csv", row.names = FALSE)



```


```{r LC_2021_PER}

library(sf)
library(raster)
library(exactextractr)
library(dplyr)
library(tidyr)

parcels <- parcels
landcover_2021 <- lc_2021

# Transform CRS of parcels to match the landcover raster if they are different
if (st_crs(parcels) != crs(landcover_2021)) {
  parcels <- st_transform(parcels, crs = crs(landcover_2021))
}

# Perform the exact extraction
coverage <- exact_extract(landcover_2021, parcels, include_cols = c("GlobalID"))
parcel_percentages <- do.call(rbind, lapply(coverage, function(x) {
  percentages <- calculate_percentages(x)
  x$percentage <- percentages
  return(x)
}))

# Spread the data to wide format and summarize
parcel_percentages_wide <- parcel_percentages %>%
  group_by(GlobalID, value) %>%
  summarize(percentage = sum(percentage, na.rm = TRUE), .groups = 'drop') %>%
  pivot_wider(names_from = value, values_from = percentage, names_prefix = "Landcover_")

# Merge with original parcels data to include geospatial information
final_dataset <- parcels %>%
  left_join(parcel_percentages_wide, by = "GlobalID")

# Select the desired columns and turn NA's to 0 for landcover columns
parcel_lc_2021 <- final_dataset %>%
  select(GlobalID, starts_with("Landcover_"), geometry) %>%
  mutate(across(starts_with("Landcover_"), ~replace_na(., 0)))

#TURN NA'S TO 0


#FILTER COLUMNS


# View the final dataset
View(parcel_lc_2021 )

# Alternatively, write to a CSV file
write.csv(final_dataset, "parcel_landcover_percentages.csv", row.names = FALSE)


```





## Final Code
```{r}

library(sf)
library(raster)
library(exactextractr)
library(dplyr)
library(tidyr)

parcels <- parcels
landcover_2016 <- lc_2016
# Assuming you have already loaded necessary libraries and defined parcels and landcover_2021

# Transform CRS of parcels to match the landcover raster if they are different
if (st_crs(parcels) != crs(landcover_2016)) {
  parcels <- st_transform(parcels, crs = crs(landcover_2016))
}

# Perform the exact extraction
coverage <- exact_extract(landcover_2016, parcels, include_cols = c("GlobalID"))

# Function to calculate and round percentages
calculate_percentages <- function(df) {
  total_area <- sum(df$coverage_fraction)
  percentages <- 100 * df$coverage_fraction / total_area
  percentages_rounded <- round(percentages, 2)  # Round percentages to 2 decimal places
  return(percentages_rounded)
}

# Apply calculate_percentages and bind results to a new data frame
parcel_percentages <- do.call(rbind, lapply(coverage, function(x) {
  percentages <- calculate_percentages(x)
  x$percentage <- percentages  # Assign rounded percentages
  return(x)
}))

# Spread the data to wide format and summarize
parcel_percentages_wide <- parcel_percentages %>%
  group_by(GlobalID, value) %>%
  summarize(percentage = sum(percentage, na.rm = TRUE), .groups = 'drop') %>%
  pivot_wider(names_from = value, values_from = percentage, names_prefix = "Landcover_")

# Merge with original parcels data to include geospatial information
final_dataset <- parcels %>%
  left_join(parcel_percentages_wide, by = "GlobalID")

# Select the desired columns and turn NA's to 0 for landcover columns
parcel_lc_2016 <- final_dataset %>%
  select(GlobalID, starts_with("Landcover_"), geometry) %>%
  mutate(across(starts_with("Landcover_"), ~replace_na(round(., 2), 0)))  # Ensure rounding here just in case and replace NA with 0

# View the final dataset
View(parcel_lc_2016)



```

```{r}
library(sf)
library(raster)
library(exactextractr)
library(dplyr)
library(tidyr)
parcels <- parcels
landcover_2021 <- lc_2021
# Assuming you have already loaded necessary libraries and defined parcels and landcover_2021

# Transform CRS of parcels to match the landcover raster if they are different
if (st_crs(parcels) != crs(landcover_2021)) {
  parcels <- st_transform(parcels, crs = crs(landcover_2021))
}

# Perform the exact extraction
coverage <- exact_extract(landcover_2021, parcels, include_cols = c("GlobalID"))

# Function to calculate and round percentages
calculate_percentages <- function(df) {
  total_area <- sum(df$coverage_fraction)
  percentages <- 100 * df$coverage_fraction / total_area
  percentages_rounded <- round(percentages, 2)  # Round percentages to 2 decimal places
  return(percentages_rounded)
}

# Apply calculate_percentages and bind results to a new data frame
parcel_percentages <- do.call(rbind, lapply(coverage, function(x) {
  percentages <- calculate_percentages(x)
  x$percentage <- percentages  # Assign rounded percentages
  return(x)
}))

# Spread the data to wide format and summarize
parcel_percentages_wide <- parcel_percentages %>%
  group_by(GlobalID, value) %>%
  summarize(percentage = sum(percentage, na.rm = TRUE), .groups = 'drop') %>%
  pivot_wider(names_from = value, values_from = percentage, names_prefix = "Landcover_")

# Merge with original parcels data to include geospatial information
final_dataset <- parcels %>%
  left_join(parcel_percentages_wide, by = "GlobalID")

# Select the desired columns and turn NA's to 0 for landcover columns
parcel_lc_2021 <- final_dataset %>%
  select(GlobalID, starts_with("Landcover_"), geometry) %>%
  mutate(across(starts_with("Landcover_"), ~replace_na(round(., 2), 0)))  # Ensure rounding here just in case and replace NA with 0

# View the final dataset
View(parcel_lc_2021)



```
